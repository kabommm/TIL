# 빅오 표기법(시간 복잡도)

시간복잡도란 주어진 문제를 해결하기 위한 연산 횟수

연산 횟수 = 알고리즘 시간 복잡도 x 데이터 크기 ex) 시간복잡도가 n^2인 버블정렬에서 데이터의 크기가 100만이면 연산 횟수는 (100만)^2 즉, n자리에 데이터 크기를 넣어준다.

수행시간: 1억 번의 연산 = 1초의 시간 ex) 시간제한 2초 = 2억 번의 연산안에 답이 나와야함

## 시간 복잡도 유형

- 빅-오메가: 최선일 때 연산 횟수를 나타낸 표기법
- 빅-세타: 보통일 때 연산 횟수를 나타낸 표기법
- 빅-오: 최악일 때 연산 횟수를 나타낸 표기법

### 코딩 테스트 할 때는 항상 최악의 경우를 염두해야 하기 때문에 빅-오 표기법 사용

### 코딩 테스트 절차

1. 시간 복잡도 탐색

코드 짜기 전 -> 데이터의 크기와 시간 제한을 보고 어떤 알고리즘을 사용해야 제한 시간안에 연산이 가능한지 적합한 알고리즘을
찾아서 코드 짜기, 되도록이면 더 작은 시간복잡도를 시도하고 대부분은O(n)이다.

코드를 짜고 나서 -> 시간 복잡도 효율이 더 좋은(작은) 방식으로 가능한지 확인

![](https://github.com/kabommm/TIL/blob/main/Algorithm/img/Data%20Structure.png)

2. 기본 자료구조(배열, 리스트) 탐색

문제가 요구하는 조건에 따라 두 자료구조의 특징 중 적절한 자료구조를 선택한다. 

데이터에 접근하는 경우가 많다. + 크기를 늘리거나 줄이지 않는다. + -> 배열로 간다.

데이터의 크기가 변하기 쉬운 데이터를 다룬다. + 삽입, 삭제가 많다.-> 리스트로 간다.

## 시간 복잡도 도출 기준

- 상수는 시간 복잡도 계산에서 제외한다. ex) N = 3N
- 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

## O(1)

- 스택에서 push 또는 pop
- 해쉬 테이블

## O(log n)

- 이진 탐색 트리

## O(n)

- 트리 순회
- linked list 순회

## O(nlog n)

- 퀵 정렬
- 병합 정렬
- 힙 정렬

## O(n^2)

- 삽입 정렬
- 버블 정렬
- 선택 정렬

![](https://github.com/kabommm/TIL/blob/main/Algorithm/img/Time%20Complexity.png)

## 참고

인프런 강의-알고리즘 코딩테스트
