# 합병 정렬

- 시간 복잡도: O(nlogn)

- 공간 복잡도: O(n)

리스트를 분할을 반복하여 최대한 작게 쪼개진 시점에 부분리스트에서 인접한 원소들끼리 비교하여 정렬하는 방식

문제를 분할하고, 분할한 문제를 정복하여 합치는 과정으로 분할 정복 알고리즘을 기반으로 정렬되는 방식

데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하기 때문에 제자리 정렬(in-place sort)이 아니다.

합병정렬의 구조상 최대한 작게 문제를 쪼개어 앞의 부분리스트부터 차례대로 합쳐나가기 때문에 '안정 정렬'이기도 하다.

- 과정(오름차순 기준)

1. 주어진 리스트를 절반으로 분할하여 부분리스트로 나눈다. (Divide : 분할)

2. 해당 부분리스트의 길이가 1이 아니라면 1번 과정을 되풀이한다.

3. 인접한 부분리스트끼리 정렬하여 합친다. (Conqure : 정복)

![]()

- 삽입 정렬 구현

![]()

![]()

위와같이 분할정복 방식으로 두 부분을 짤라 들어가면서 서브 문제를 해결하는 방식으로 구현 되는 가장 일반적인 방식(Top-Down)

위 방식에서 착안하여 부분리스트로 나누는 과정만 변경하여 Bottom-Up 방식으로도 구현할 수 있다.

![]()

대부분의 경우 정렬 과정은 최대한 재귀는 피하여 구현하는게 일반적이기 때문에 위와 같은 Bottom-Up 으로 구현하는 것이 좋다.

- 시간 복잡도 유도

N개의 데이터가 있는 리스트를 1개까지 쪼개어 트리로 나타내게 되면 이진트리(Binary Tree) 형태로 나온다.

N개 노드에 대한 이진트리의 높이(h)는 logN

우리가 두 개의 서브리스트(배열)을 sorted 배열에 합치는 merge과정을 생각해보자.

이미 두 서브리스트는 정렬된 형태라 앞 원소부터 차례대로 비교하며 안착시키기만 하면 된다.

즉, 아무리 최악의 상황이어도 두 개의 서브리스트 원소 개수만큼의 비교 및 새 배열로 안착시킨다.

그러면 i번 째 레벨에서 노드의 개수가 (2^i) 개이고, 노드의 크기. 한 노드에 들어있는 원소 개수는 N/(2^i) 개다.

이를 곱하면 한 레벨에서 비교작업에 대한 시간 복잡도는 O((2^i) × N/(2^i)) 이고 이는 곧 O(N)이다.

그리고 O(N)의 비교작업을 트리의 높이인 logN -1 번 수행하므로 다음과 같이 표기할 수 있다.

O(N) × O(logN)

최종적으로 위를 계산하면 O(NlogN) 의 시간복잡도를 갖는 것을 알 수 있다. 

-> 1부터 N-1까지 전체의 합 공식N(N-1)/2에서 (N^2 -N) <= (N^2)이므로 -N제외 그리고 상수 2/1 생략 -> N^2

## 참고

<https://st-lab.tistory.com/233>
